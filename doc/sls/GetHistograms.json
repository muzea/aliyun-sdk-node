{"summary":"调用GetHistograms接口查询指定Logstore中满足查询语法条件的日志分布情况。","path":"/logstores/{logstore}/index?type=histogram","methods":["get"],"schemes":["http","https"],"security":[{"AK":[]}],"consumes":["application/json"],"produces":["application/json"],"operationType":"read","deprecated":false,"systemTags":{"operationType":"get"},"parameters":[{"name":"project","in":"host","schema":{"title":"project 名称。","description":"project 名称。","type":"string","required":true,"example":"ali-test-project"}},{"name":"logstore","in":"path","schema":{"title":"logstore 名称。","description":"Logstore名称。","type":"string","required":true,"example":"test-logstore"}},{"name":"from","in":"query","schema":{"title":"查询开始时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。\n\n时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。","description":"子时间区间的开始时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。","type":"integer","format":"int64","required":true,"example":"1409529600"}},{"name":"to","in":"query","schema":{"title":"查询结束时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。\n\n时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。","description":"子时间区间的结束时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。","type":"integer","format":"int64","required":true,"example":"1409569200"}},{"name":"topic","in":"query","schema":{"title":"日志主题。","description":"日志主题。","type":"string","required":false,"example":"topic"}},{"name":"query","in":"query","schema":{"title":"查询语句。仅支持查询语句，不支持分析语句。关于查询语句的详细语法，请参见查询语法。","description":"查询语句。仅支持查询语句，不支持分析语句。关于查询语句的详细语法，请参见[查询语法](~~43772~~)。","type":"string","required":false,"example":"with_pack_meta"}}],"responses":{"200":{"headers":{"Server":{"schema":{"title":"服务器名称。","type":"string","example":"nginx"}},"Content-Type":{"schema":{"title":"返回的响应体的内容格式。","type":"string","example":"application/json"}},"Content-Length":{"schema":{"title":"响应内容长度。","type":"string","example":"0"}},"Connection":{"schema":{"title":"是否长链接。取值包括：  close：不是长链接，则每个HTTP请求都会重新建立TCP连接。 keep-alive：长链接，TCP连接建立后保持连接状态，节省连接所需时间和带宽。","type":"string","example":"close"}},"Date":{"schema":{"title":"返回响应的时间。","type":"string","example":"Sun, 27 May 2018 08:25:04 GMT"}},"x-log-requestid":{"schema":{"title":"服务端产生的标识，该请求的唯一ID。","type":"string","example":"5B0A6B60BB6EE39764D458B5"}}},"schema":{"type":"array","items":{"type":"object","properties":{"from":{"title":"子时间区间的开始时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。\n\n时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。","description":"子时间区间的开始时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。\n\n时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。","type":"integer","format":"int64","example":"1409529600"},"to":{"title":"子时间区间的结束时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。\n\n时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。","description":"子时间区间的结束时间点。UNIX时间戳格式，表示从1970-1-1 00:00:00 UTC计算起的秒数。\n\n时间区间遵循“左闭右开”原则，即该时间区间包括区间开始时间点，但不包括区间结束时间点。如果from和to的值相同，则为无效区间，函数直接返回错误。","type":"integer","format":"int64","example":"1409569200"},"count":{"title":"该子时间区间内查询到的日志条数。","description":"该子时间区间内查询到的日志条数。","type":"integer","format":"int64","example":"2"},"progress":{"title":"当前查询结果在该子时间区间内的结果是否完整。\n\nComplete：查询已经完成，返回结果为完整结果。\n\nIncomplete：查询已经完成，返回结果为不完整结果，需要重复请求以获得完整结果。","description":"当前查询结果在该子时间区间内的结果是否完整。\n\nComplete：查询已经完成，返回结果为完整结果。\n\nIncomplete：查询已经完成，返回结果为不完整结果，需要重复请求以获得完整结果。","type":"string","example":"Complete"}}}}}},"responseDemo":"[{\"type\":\"json\",\"example\":\"[\\n  {\\n    \\\"from\\\": 1409529600,\\n    \\\"to\\\": 1409569200,\\n    \\\"count\\\": 2,\\n    \\\"progress\\\": \\\"Complete\\\"\\n  }\\n]\",\"errorExample\":\"\"},{\"type\":\"xml\",\"example\":\"\",\"errorExample\":\"\"}]","title":"查询日志分布情况","description":"### 接口说明\n\n- 请求语法中Host由Project名称和日志服务Endpoint构成，您需要在Host中指定Project。\n- 该接口的响应中子区间划分方式是一直稳定的。如果您在请求查询的时间区间不变，则响应中子区间划分结果也不会改变。\n- 当查询涉及的日志数量变化非常大时，日志服务API无法预测需要调用多少次该接口来获取完整结果。所以需要您查看每次请求返回结果中的progress成员状态值，根据成员状态值来确定是否需要重复调用该接口来获取最终完整结果。每次重复调用该接口都会重新消耗相同数量的查询CU。\n- 从日志写入日志库到查询接口（GetHistograms和GetLogs）查到该日志，延时时长因写入日志类型不同而异。日志服务按日志时间戳把日志分为如下两类：\n    - 实时数据：日志中时间点为服务器当前时间点（-180秒，900秒]。例如，日志时间为UTC 2014-09-25 12:03:00，服务器收到时为UTC 2014-09-25 12:05:00，则该日志被视作实时数据处理。实时数据从写入到在日志查询界面查询到该数据的延迟为3秒。\n    - 历史数据：日志中时间点为服务器当前时间点\\[-7x86400秒，-180秒）。例如，日志时间为UTC 2014-09-25 12:00:00，服务器收到时为UTC 2014-09-25 12:05:00，则该日志被作为历史数据处理，一般出现在补数据场景下。\n   其中，实时数据写入至可查询的最大延时为3秒，99.9%情况下1秒内即可查询完毕。\n\n> 日志服务将日志时间（字段名称为\\_\\_time\\_\\_）和服务器收到时间（字段名称为\\_\\_tag\\_\\_:\\_\\_receive\\_time\\__）做差，若其差值位于\\(-180秒，900秒]范围，则为实时数据，若其差位于\\[-7x86400秒，-180秒），则为历史数据。\n\n- 日志服务提供Java SDK的GetHistograms查询使用示例。更多信息，请参见[使用GetHistograms查询日志分布数量](~~462234~~)。","extraInfo":"| HttpStatusCode  | ErrorCode  | ErrorMessage  | 错误码描述  |\n| :------------ | :------------ | :------------ | :------------ |\n| 404  | ProjectNotExist| Project does not exist.  | Project不存在。  |\n| 404  | LogStoreNotExist  | Logstore does not exist.  | Logstore不存在。  |\n| 400  |  InvalidTimeRange|  request time range is invalid. | 请求的时间区间无效。  |\n|  400 |  InvalidQueryString|  query string is invalid. | 请求的查询语句无效。  |\n|  500 |  InternalServerError |  Specified Server Error Message. | 内部服务调用错误。 |\n\n更多信息，请参见[通用错误码](~~29013~~)。\n"}